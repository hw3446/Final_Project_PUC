[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tutorial",
    "section": "",
    "text": "Intro\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nApr 22, 2025\n\n\nHannah Wilkie\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Descriptive 1/index.html",
    "href": "posts/Descriptive 1/index.html",
    "title": "Intro",
    "section": "",
    "text": "#Part 1 ##Descriptive 1\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.4.1\n\n\nWarning: package 'ggplot2' was built under R version 4.4.3\n\n\nWarning: package 'tibble' was built under R version 4.4.1\n\n\nWarning: package 'tidyr' was built under R version 4.4.1\n\n\nWarning: package 'readr' was built under R version 4.4.1\n\n\nWarning: package 'purrr' was built under R version 4.4.1\n\n\nWarning: package 'dplyr' was built under R version 4.4.3\n\n\nWarning: package 'stringr' was built under R version 4.4.1\n\n\nWarning: package 'forcats' was built under R version 4.4.1\n\n\nWarning: package 'lubridate' was built under R version 4.4.1\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(broom)\n\nWarning: package 'broom' was built under R version 4.4.1\n\nlibrary(performance)\n\nWarning: package 'performance' was built under R version 4.4.3\n\nlibrary(ordinal)\n\nWarning: package 'ordinal' was built under R version 4.4.2\n\n\n\nAttaching package: 'ordinal'\n\nThe following object is masked from 'package:dplyr':\n\n    slice\n\nlibrary(car)\n\nWarning: package 'car' was built under R version 4.4.1\n\n\nLoading required package: carData\n\n\nWarning: package 'carData' was built under R version 4.4.1\n\n\n\nAttaching package: 'car'\n\nThe following object is masked from 'package:dplyr':\n\n    recode\n\nThe following object is masked from 'package:purrr':\n\n    some\n\nlibrary(ggeffects)\n\nWarning: package 'ggeffects' was built under R version 4.4.1\n\nlibrary(gofcat)\n\nWarning: package 'gofcat' was built under R version 4.4.2\n\nlibrary(brms)\n\nWarning: package 'brms' was built under R version 4.4.3\n\n\nLoading required package: Rcpp\n\n\nWarning: package 'Rcpp' was built under R version 4.4.1\n\n\nLoading 'brms' package (version 2.22.0). Useful instructions\ncan be found by typing help('brms'). A more detailed introduction\nto the package is available through vignette('brms_overview').\n\nAttaching package: 'brms'\n\nThe following object is masked from 'package:stats':\n\n    ar\n\nlibrary(emmeans)\n\nWarning: package 'emmeans' was built under R version 4.4.2\n\n\nWelcome to emmeans.\nCaution: You lose important information if you filter this package's results.\nSee '? untidy'\n\nlibrary(knitr)\n\nWarning: package 'knitr' was built under R version 4.4.1\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(gridExtra)\n\nWarning: package 'gridExtra' was built under R version 4.4.1\n\n\n\nAttaching package: 'gridExtra'\n\nThe following object is masked from 'package:dplyr':\n\n    combine\n\nlibrary(grid)\nlibrary(MASS) \n\n\nAttaching package: 'MASS'\n\nThe following object is masked from 'package:dplyr':\n\n    select\n\nlibrary(reshape2) \n\nWarning: package 'reshape2' was built under R version 4.4.2\n\n\n\nAttaching package: 'reshape2'\n\nThe following object is masked from 'package:tidyr':\n\n    smiths\n\nlibrary(reshape) \n\nWarning: package 'reshape' was built under R version 4.4.2\n\n\n\nAttaching package: 'reshape'\n\nThe following objects are masked from 'package:reshape2':\n\n    colsplit, melt, recast\n\nThe following object is masked from 'package:lubridate':\n\n    stamp\n\nThe following object is masked from 'package:dplyr':\n\n    rename\n\nThe following objects are masked from 'package:tidyr':\n\n    expand, smiths\n\nlibrary(logistf)\n\nWarning: package 'logistf' was built under R version 4.4.3\n\nlibrary(corrplot)\n\nWarning: package 'corrplot' was built under R version 4.4.3\n\n\ncorrplot 0.95 loaded\n\n\nFirst we load the data for the first half of the concert, removing columns we don’t want. I’ve also recoded the hall locations into two factors, ‘Downstairs’ and ‘Upstairs’.\n\n#Loading dataset, sheet 1\n\nlibrary(conflicted)\n\nWarning: package 'conflicted' was built under R version 4.4.3\n\nconflict_prefer(\"filter\", \"dplyr\")\n\n[conflicted] Will prefer dplyr::filter over any other package.\n\ninput1 &lt;- \"https://raw.githubusercontent.com/hw3446/Final_Project_PUC/main/input/PUC1.csv\"\ndata_paper &lt;- read_csv(input1)\n\nRows: 54 Columns: 26\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (12): Sensory_sensations, Movement_mem, Mem_description, Mem_music_evoke...\ndbl (14): Participant_number, Fictional_story, Abstract_shapes, Life_experie...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n##\n\nFirst we need to recode some of the values in the dataframe.\n\nrecode &lt;- c(\"1\" = \"Not at all\",\n                \"2\" = \"A small amount of the time\",\n                \"3\" = \"A moderate amount of the time\",\n                \"4\" = \"Most of the time\",\n                \"5\" = \"All of the time\")\n\nrecode2 &lt;- c(\"1\" = \"Not at all\",\n             \"2\" = \"Slightly\",\n             \"3\" = \"Moderately\",\n             \"4\" = \"Mostly\",\n             \"5\" = \"Entirely\")\n\nrecode3 &lt;- c(\"1\" = \"Very rarely\",\n             \"2\" = \"Somewhat rarely\",\n             \"3\" = \"Moderately frequently\",\n             \"4\" = \"Frequently\",\n             \"5\" = \"Very frequently\")\n\ndata_paper[, 2:10] &lt;- lapply(data_paper[, 2:10], function(x) recode[as.character(x)])\ndata_paper[, 13:15] &lt;- lapply(data_paper[, 13:15], function(x) recode2[as.character(x)])\ndata_paper[, 18:20] &lt;- lapply(data_paper[, 18:20], function(x) recode2[as.character(x)])\ndata_paper[, 24] &lt;- lapply(data_paper[, 24], function(x) recode3[as.character(x)])\n\nThen we load the qualtrics data.\n\nlibrary(conflicted)\nconflict_prefer(\"filter\", \"dplyr\")\n\n[conflicted] Removing existing preference.\n[conflicted] Will prefer dplyr::filter over any other package.\n\ninput2 &lt;- \"https://raw.githubusercontent.com/hw3446/Final_Project_PUC/main/input_qualtrics/PUC1.csv\"\ndata_qualtrics &lt;- read_csv(input2)\n\nRows: 56 Columns: 41\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (41): StartDate, EndDate, Status, Progress, Duration, Finished, Recorded...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ndata_qualtrics &lt;- data_qualtrics %&gt;% dplyr::filter(Finished == \"TRUE\") %&gt;% \n  dplyr::select(-StartDate, -EndDate, -Status, -Progress, -Duration, \n         -RecordedDate, -DistributionChannel, -UserLanguage, -Finished, -Q1, -ResponseId)\n\nThe way people select composer and movements is different for the two surveys so we need to get them in a matching format:\n\ncomposer_initials &lt;- data.frame(\n  composer = c(\"Beethoven\", \"Hough\"),\n  composer_initial = c(\"B\", \"H\")\n)\n\ndata_long &lt;- data_qualtrics %&gt;%\n  pivot_longer(\n    cols = starts_with(\"Movement\"),\n    names_to = \"source_col\",\n    values_to = \"movement_label\"\n  ) %&gt;%\n  filter(!is.na(movement_label)) %&gt;%\n  mutate(\n    composer = case_when(\n      str_detect(source_col, \"_B_\") ~ \"Beethoven\",\n      str_detect(source_col, \"_H_\") ~ \"Hough\"\n    ),\n    type = case_when(\n      str_detect(source_col, \"_mem$\") ~ \"mem\",\n      str_detect(source_col, \"_story$\") ~ \"story\"\n    ),\n    movement = as.integer(str_extract(movement_label, \"\\\\d+\"))\n  ) %&gt;%\n  left_join(composer_initials, by = \"composer\") %&gt;%\n  mutate(code = paste0(composer_initial, movement))\n\ndata_wide &lt;- data_long %&gt;%\n  dplyr::select(ID, type, code) %&gt;%\n  pivot_wider(\n    names_from = type,\n    values_from = code,\n    names_prefix = \"Movement_\"\n  )\n\nfinal_qualtrics &lt;- data_qualtrics %&gt;%\n  left_join(data_wide, by = \"ID\")\n\n\n# Combine the data frames\ndata &lt;- bind_rows(data_paper, final_qualtrics)\ndata &lt;- data%&gt;% dplyr::select(-Movement_H_story, -Movement_B_story, -Piece_story, -Movement_H_mem, -Movement_B_mem, -Piece_mem)\n\nA dataframe is created showing thought types in a long format with counts for each frequency.\n\nthought_types &lt;- c(\"Fictional_story\", \"Abstract_shapes\", \"Sensory_sensations\", \"Life_experiences\", \"Media\", \"Music\", \"Future_plans\", \"Building\", \"Everyday\")\n\nthoughts_long &lt;- data %&gt;%\n  pivot_longer(cols = thought_types,\n               names_to = \"Category\", \n               values_to = \"Response\") %&gt;%\n  count(Category, Response) %&gt;% \n  mutate(Response = factor(Response, \n                           levels = c(\"Not at all\", \n                                      \"A small amount of the time\", \n                                      \"A moderate amount of the time\", \n                                      \"Most of the time\", \n                                      \"All of the time\"))) %&gt;% \n  mutate(Category = factor(Category, levels = rev(c(\"Fictional_story\", \n                                                    \"Abstract_shapes\", \n                                                    \"Sensory_sensations\", \n                                                    \"Life_experiences\", \n                                                    \"Media\", \n                                                    \"Music\", \n                                                    \"Future_plans\", \n                                                    \"Building\", \n                                                    \"Everyday\")))) %&gt;% filter(!is.na(Response))\n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %&gt;% select(thought_types)\n\n  # Now:\n  data %&gt;% select(all_of(thought_types))\n\nSee &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;.\n\n\nThis dataframe is used for the first plot, which shows the counts for each type of thought during the first half.\n\nggplot(thoughts_long, aes(x = Response, y = Category, fill = n)) +\n  geom_tile(color = \"white\") +  # Add white borders to tiles\n  scale_fill_gradient(low = \"lightblue\", high = \"darkblue\") +  # Adjust color gradient\n  labs(title = \"Counts for Thought Types, First Half\", x = NULL, y = NULL, fill = \"Count\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels\n\n\n\n\n\n\n\n\nThen we examine the counts for the movements people select as invoking the most vivid memory or story.\n\nmems &lt;- data$Movement_mem %&gt;% na.omit() %&gt;% toupper()\nstories &lt;- data$Movement_story %&gt;% na.omit() %&gt;% toupper()\n\n\n# Split values by \";\", \",\", or whitespace\nsplit_values_mem &lt;- unlist(strsplit(mems, \"[; ,]+\"))\nsplit_values_story &lt;- unlist(strsplit(stories, \"[; ,]+\"))\n\n# Trim whitespace\nsplit_values_mem &lt;- trimws(split_values_mem)\nsplit_values_story &lt;- trimws(split_values_story)\n\n# Count occurrences\nvalue_counts_mem &lt;- table(split_values_mem)\nvalue_counts_story &lt;- table(split_values_story)\n\nThe movement counts are then plotted.\n\n#Reorder the Movement factor levels for Beethoven and Hough\n\nrecode_map &lt;- c(\"B1\" = \"Beethoven, Movement 1 — Allegro con brio\",\n                \"B2\" = \"Beethoven, Movement 2 — Adagio affettuoso ed appassionato\",\n                \"B3\" = \"Beethoven, Movement 3 — Scherzo\",\n                \"B4\" = \"Beethoven, Movement 4 — Allegro\",\n                \"H1\" = \"Hough, Movement 1 — Au boulevard\",\n                \"H2\" = \"Hough, Movement 2 — Au parc\",\n                \"H3\" = \"Hough, Movement 3 — À l'hôtel\",\n                \"H4\" = \"Hough, Movement 4 — Au théâtre\",\n                \"H5\" = \"Hough, Movement 5 — À l'église\",\n                \"H6\" = \"Hough, Movement 6 — Au marché\")\n\n\n# Recode values to descriptive names using recode_map\nrecoded_mem &lt;- dplyr::recode(split_values_mem, !!!recode_map)\nrecoded_story &lt;- dplyr::recode(split_values_story, !!!recode_map)\n\n# Convert recoded values to data frames\ndf_mem_counts &lt;- as.data.frame(table(recoded_mem))\ncolnames(df_mem_counts) &lt;- c(\"Movement\", \"count\")\n\ndf_story_counts &lt;- as.data.frame(table(recoded_story))\ncolnames(df_story_counts) &lt;- c(\"Movement\", \"count\")\n\n# Add a Composer column (Beethoven for B1-B4, Hough for H1-H6)\ndf_mem_counts$Composer &lt;- ifelse(grepl(\"^Beethoven\", df_mem_counts$Movement), \"Beethoven\", \"Hough\")\ndf_story_counts$Composer &lt;- ifelse(grepl(\"^Beethoven\", df_story_counts$Movement), \"Beethoven\", \"Hough\")\n\n# Set movement factor levels for proper ordering\ndf_mem_counts$Movement &lt;- factor(df_mem_counts$Movement, levels = recode_map)\ndf_story_counts$Movement &lt;- factor(df_story_counts$Movement, levels = recode_map)\n\n# Plot for 'memories'\nmem_plot &lt;- ggplot(df_mem_counts, aes(x = Movement, y = count, fill = Movement)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  facet_wrap(~ Composer, scales = \"free_x\") +  # Separate Beethoven & Hough\n  theme_minimal() +\n  labs(title = \"Movement Counts for Memories\", x = \"Movement\", y = \"Count\") +\n theme(axis.title.x = element_blank(),  # Remove x-axis title\n        axis.text.x = element_blank(),   # Remove x-axis labels\n        axis.ticks.x = element_blank()) +\n  scale_fill_brewer(palette = \"Set3\") + \n  guides(fill = guide_legend(title = \"Movement\")) +\n  scale_y_continuous(breaks = scales::breaks_pretty(n = 5))  \n\n# Plot for 'stories'\nstory_plot &lt;- ggplot(df_story_counts, aes(x = Movement, y = count, fill = Movement)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  facet_wrap(~ Composer, scales = \"free_x\") +  # Separate Beethoven & Hough\n  theme_minimal() +\n  labs(title = \"Movement Counts for Stories\", x = \"Movement\", y = \"Count\") +\n theme(axis.title.x = element_blank(),  # Remove x-axis title\n        axis.text.x = element_blank(),   # Remove x-axis labels\n        axis.ticks.x = element_blank()) +\n  scale_fill_brewer(palette = \"Set3\") + \n  guides(fill = guide_legend(title = \"Movement\")) +\n  scale_y_continuous(breaks = scales::breaks_pretty(n = 5)) \n\nIn the next descriptive phase, we want to look at how demographics variables are associated with different types of thoughts. First, we tidy the demographics data and make sure it’s classed in the right way.\n\n#Creating a 'floor' variable, with 2 factors showing downstairs and upstairs locations.\ndata &lt;- data %&gt;%\n  mutate(Floor = ifelse(Location %in% c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"), \"Downstairs\", \"Upstairs\")) %&gt;% relocate(Floor, .after = Location)\n\n#Removing NA.s?\ndata &lt;- data %&gt;%\n  filter(!is.na(Age) & !is.na(Gender) & !is.na(Music_listening) & !is.na(Floor) & !is.na(Fictional_story) & !is.na(Practice)) %&gt;%\n  filter(!is.infinite(Age) & !is.infinite(Gender) & !is.infinite(Music_listening) & \n         !is.infinite(Floor) & !is.infinite(Fictional_story) & !is.infinite(Practice))\n\n#Making sure demographic variables are classed in the right way.\ndata$Age &lt;- as.numeric(data$Age)\n\nWarning: NAs introduced by coercion\n\ndata$Practice &lt;- as.numeric(as.character(data$Practice))\n\nWarning: NAs introduced by coercion\n\ndata$Gender &lt;- factor(data$Gender,  levels = c('Male', 'Female', 'Other'))\ndata$Music_listening &lt;- factor(data$Music_listening, levels = c('Very rarely', 'Somewhat rarely', 'Moderately frequently', 'Frequently', 'Very frequently'))\ndata$Floor &lt;- factor(data$Floor, levels = c('Downstairs', 'Upstairs'))\ndata$Fictional_story &lt;- factor(data$Fictional_story, \n                               levels = c(\"Not at all\", \"A small amount of the time\", \n                                          \"A moderate amount of the time\", \n                                          \"Most of the time\", \"All of the time\"))\n\nVarious descriptive plots can be made, but there are 3 below for age, gender and floor.\n\nDescriptive plot for Age and types of thought – age is converted into a grouped variable:\n\n\n# Create Age bins\ndata &lt;- data %&gt;%\n  mutate(Age_group = cut(Age, \n                         breaks = seq(floor(min(Age, na.rm = TRUE)), \n                                      ceiling(max(Age, na.rm = TRUE)) + 20, by = 5), \n                         include.lowest = TRUE, \n                         right = FALSE))\n\n# List of outcome variables\noutcome_vars &lt;- c(\"Fictional_story\", \"Abstract_shapes\", \"Sensory_sensations\", \n                  \"Life_experiences\", \"Media\", \"Music\", \"Future_plans\", \n                  \"Building\", \"Everyday\")\n\n# Converting outcome variables to factors with consistent levels for each thought type\ndata[outcome_vars] &lt;- lapply(data[outcome_vars], factor, \n                             levels = c(\"Not at all\", \"A small amount of the time\", \n                                        \"A moderate amount of the time\", \"Most of the time\", \n                                        \"All of the time\"))\n\n# Creating a single summary_data dataframe\nsummary_data &lt;- data %&gt;%\n  pivot_longer(cols = all_of(outcome_vars), names_to = \"Outcome\", values_to = \"Response\") %&gt;%\n  group_by(Age_group, Outcome, Response) %&gt;%\n  summarise(count = n(), .groups = \"drop\") %&gt;%\n  group_by(Age_group, Outcome) %&gt;%\n  mutate(prop = count / sum(count)) %&gt;%\n  ungroup()\n\n# Looping through each outcome variable to generate plots\nplot_list &lt;- list()\n\nfor (outcome in outcome_vars) {\n    plot_data &lt;- summary_data %&gt;% filter(Outcome == outcome)\n    plot &lt;- ggplot(plot_data, aes(x = Age_group, y = prop, fill = Response)) +\n      geom_bar(stat = \"identity\", position = \"stack\", alpha = 0.8) + \n      labs(x = \"\\nAge Group\", y = \"Proportion\\n\", title = paste(outcome)) +\n      scale_fill_manual(name = \"Response Level\",\n                        values = setNames(c(\"#deebf7\", \"#9ecae1\", \"#3182bd\", \"#08519c\", \"#08306b\"),\n                                          levels(data[[outcome]]))) +\n      theme_minimal() + \n      theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n  plot_list[[outcome]] &lt;- plot\n}\n\n# Arranging plots in a grid and saving\n\ntitle_grob &lt;- textGrob(\"Types of Thoughts by Age Group, First Half\", gp = gpar(fontsize = 16, fontface = \"bold\"))\n\nAge_thoughts_grid &lt;- invisible(grid.arrange(\n  grobs = plot_list, \n  ncol = 3, \n  top = title_grob  \n))\n\n\n\n\n\n\n\n\n\nDescriptive plot for gender and types of thought – for now gender has been filtered for male and female.\n\n\n# Remove missing values + filter\ndata &lt;- data %&gt;%\n  filter(!is.na(Gender)) %&gt;% filter(Gender != 'Other')\n\n# Create a single summary_data dataframe\nsummary_data &lt;- data %&gt;%\n  pivot_longer(cols = all_of(outcome_vars), names_to = \"Outcome\", values_to = \"Response\") %&gt;%\n  group_by(Gender, Outcome, Response) %&gt;%\n  summarise(count = n(), .groups = \"drop\") %&gt;%\n  group_by(Gender, Outcome) %&gt;%\n  mutate(prop = count / sum(count)) %&gt;%\n  ungroup()\n\n# Looping through each outcome variable to generate plots\nplot_list &lt;- list()\n\nfor (outcome in outcome_vars) {\n    plot_data &lt;- summary_data %&gt;% filter(Outcome == outcome)\n    plot &lt;- ggplot(plot_data, aes(x = Gender, y = prop, fill = Response)) +\n      geom_bar(stat = \"identity\", position = \"stack\", alpha = 0.8) + \n      labs(x = \"\\nGender\", y = \"Proportion\\n\", title = paste(outcome)) +\n      scale_fill_manual(name = \"Response Level\",\n                        values = setNames(c(\"#deebf7\", \"#9ecae1\", \"#3182bd\", \"#08519c\", \"#08306b\"),\n                                          levels(data[[outcome]]))) +\n      theme_minimal() + \n      theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n  plot_list[[outcome]] &lt;- plot\n}\n\ntitle_grob &lt;- textGrob(\"Types of Thoughts by Gender, First Half\", gp = gpar(fontsize = 16, fontface = \"bold\"))\n\nGender_thoughts_grid &lt;- grid.arrange(\n  grobs = plot_list, \n  ncol = 3, \n  top = title_grob  \n)\n\n\n\n\n\n\n\n\n\nDescriptive plot for floor\n\n\n# Remove missing values\ndata &lt;- data %&gt;%\n  filter(!is.na(Floor))\n\n# Create a single summary_data dataframe\nsummary_data &lt;- data %&gt;%\n  pivot_longer(cols = all_of(outcome_vars), names_to = \"Outcome\", values_to = \"Response\") %&gt;%\n  group_by(Floor, Outcome, Response) %&gt;%\n  summarise(count = n(), .groups = \"drop\") %&gt;%\n  group_by(Floor, Outcome) %&gt;%\n  mutate(prop = count / sum(count)) %&gt;%\n  ungroup()\n\n# Looping through each outcome variable to generate plots\nplot_list &lt;- list()\n\nfor (outcome in outcome_vars) {\n    plot_data &lt;- summary_data %&gt;% filter(Outcome == outcome)\n    plot &lt;- ggplot(plot_data, aes(x = Floor, y = prop, fill = Response)) +\n      geom_bar(stat = \"identity\", position = \"stack\", alpha = 0.8) + \n      labs(x = \"\\nFloor\", y = \"Proportion\\n\", title = paste(outcome)) +\n      scale_fill_manual(name = \"Response Level\",\n                        values = setNames(c(\"#deebf7\", \"#9ecae1\", \"#3182bd\", \"#08519c\", \"#08306b\"),\n                                          levels(data[[outcome]]))) +\n      theme_minimal() + \n      theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n  plot_list[[outcome]] &lt;- plot\n}\n\ntitle_grob &lt;- textGrob(\"Types of Thoughts by Floor, First Half\", gp = gpar(fontsize = 16, fontface = \"bold\"))\n\nFloor_thoughts_grid &lt;- grid.arrange(\n  grobs = plot_list, \n  ncol = 3, \n  top = title_grob  \n)"
  }
]