{
  "hash": "846bd1e27f40a0405b486fb163ebd6e2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Distribution of thought types and Movements\"\nauthor: \"Hannah Wilkie\"\ndate: \"2025-04-22\"\ncategories: [news, code, analysis]\nimage: \"image.jpg\"\nexecute:\n  warning: false\n---\n\n\n\n#Part 1 ##Descriptive 1\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(broom)\nlibrary(performance)\nlibrary(ordinal)\nlibrary(car)\nlibrary(ggeffects)\nlibrary(gofcat)\nlibrary(brms)\nlibrary(emmeans)\nlibrary(knitr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(gridExtra)\nlibrary(grid)\nlibrary(MASS) \nlibrary(reshape2) \nlibrary(reshape) \nlibrary(logistf)\nlibrary(corrplot)\n```\n:::\n\n\n\nFirst we load the data for the first half of the concert, removing columns we don't want. I've also recoded the hall locations into two factors, 'Downstairs' and 'Upstairs'.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Loading dataset, sheet 1\n\nlibrary(conflicted)\nconflict_prefer(\"filter\", \"dplyr\")\ninput1 <- \"https://raw.githubusercontent.com/hw3446/Final_Project_PUC/main/input/PUC1.csv\"\ndata_paper <- read_csv(input1)\n##\n```\n:::\n\n\n\nFirst we need to recode some of the values in the dataframe.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrecode <- c(\"1\" = \"Not at all\",\n                \"2\" = \"A small amount of the time\",\n                \"3\" = \"A moderate amount of the time\",\n                \"4\" = \"Most of the time\",\n                \"5\" = \"All of the time\")\n\nrecode2 <- c(\"1\" = \"Not at all\",\n             \"2\" = \"Slightly\",\n             \"3\" = \"Moderately\",\n             \"4\" = \"Mostly\",\n             \"5\" = \"Entirely\")\n\nrecode3 <- c(\"1\" = \"Very rarely\",\n             \"2\" = \"Somewhat rarely\",\n             \"3\" = \"Moderately frequently\",\n             \"4\" = \"Frequently\",\n             \"5\" = \"Very frequently\")\n\ndata_paper[, 2:10] <- lapply(data_paper[, 2:10], function(x) recode[as.character(x)])\ndata_paper[, 13:15] <- lapply(data_paper[, 13:15], function(x) recode2[as.character(x)])\ndata_paper[, 18:20] <- lapply(data_paper[, 18:20], function(x) recode2[as.character(x)])\ndata_paper[, 24] <- lapply(data_paper[, 24], function(x) recode3[as.character(x)])\n```\n:::\n\n\n\nThen we load the qualtrics data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(conflicted)\nconflict_prefer(\"filter\", \"dplyr\")\ninput2 <- \"https://raw.githubusercontent.com/hw3446/Final_Project_PUC/main/input_qualtrics/PUC1.csv\"\ndata_qualtrics <- read_csv(input2)\ndata_qualtrics <- data_qualtrics %>% dplyr::filter(Finished == \"TRUE\") %>% \n  dplyr::select(-StartDate, -EndDate, -Status, -Progress, -Duration, \n         -RecordedDate, -DistributionChannel, -UserLanguage, -Finished, -Q1, -ResponseId)\n```\n:::\n\n\n\nThe way people select composer and movements is different for the two surveys so we need to get them in a matching format:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomposer_initials <- data.frame(\n  composer = c(\"Beethoven\", \"Hough\"),\n  composer_initial = c(\"B\", \"H\")\n)\n\ndata_long <- data_qualtrics %>%\n  pivot_longer(\n    cols = starts_with(\"Movement\"),\n    names_to = \"source_col\",\n    values_to = \"movement_label\"\n  ) %>%\n  filter(!is.na(movement_label)) %>%\n  mutate(\n    composer = case_when(\n      str_detect(source_col, \"_B_\") ~ \"Beethoven\",\n      str_detect(source_col, \"_H_\") ~ \"Hough\"\n    ),\n    type = case_when(\n      str_detect(source_col, \"_mem$\") ~ \"mem\",\n      str_detect(source_col, \"_story$\") ~ \"story\"\n    ),\n    movement = as.integer(str_extract(movement_label, \"\\\\d+\"))\n  ) %>%\n  left_join(composer_initials, by = \"composer\") %>%\n  mutate(code = paste0(composer_initial, movement))\n\ndata_wide <- data_long %>%\n  dplyr::select(ID, type, code) %>%\n  pivot_wider(\n    names_from = type,\n    values_from = code,\n    names_prefix = \"Movement_\"\n  )\n\nfinal_qualtrics <- data_qualtrics %>%\n  left_join(data_wide, by = \"ID\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Combine the data frames\ndata <- bind_rows(data_paper, final_qualtrics)\ndata <- data%>% dplyr::select(-Movement_H_story, -Movement_B_story, -Piece_story, -Movement_H_mem, -Movement_B_mem, -Piece_mem)\n```\n:::\n\n\n\nA dataframe is created showing thought types in a long format with counts for each frequency.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthought_types <- c(\"Fictional_story\", \"Abstract_shapes\", \"Sensory_sensations\", \"Life_experiences\", \"Media\", \"Music\", \"Future_plans\", \"Building\", \"Everyday\")\n\nthoughts_long <- data %>%\n  pivot_longer(cols = thought_types,\n               names_to = \"Category\", \n               values_to = \"Response\") %>%\n  count(Category, Response) %>% \n  mutate(Response = factor(Response, \n                           levels = c(\"Not at all\", \n                                      \"A small amount of the time\", \n                                      \"A moderate amount of the time\", \n                                      \"Most of the time\", \n                                      \"All of the time\"))) %>% \n  mutate(Category = factor(Category, levels = rev(c(\"Fictional_story\", \n                                                    \"Abstract_shapes\", \n                                                    \"Sensory_sensations\", \n                                                    \"Life_experiences\", \n                                                    \"Media\", \n                                                    \"Music\", \n                                                    \"Future_plans\", \n                                                    \"Building\", \n                                                    \"Everyday\")))) %>% filter(!is.na(Response))\n```\n:::\n\n\n\nThis dataframe is used for the first plot, which shows the counts for each type of thought during the first half.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(thoughts_long, aes(x = Response, y = Category, fill = n)) +\n  geom_tile(color = \"white\") +  # Add white borders to tiles\n  scale_fill_gradient(low = \"lightblue\", high = \"darkblue\") +  # Adjust color gradient\n  labs(title = \"Counts for Thought Types, First Half\", x = NULL, y = NULL, fill = \"Count\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels\n```\n\n::: {.cell-output-display}\n![](Descriptive1_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\nThen we examine the counts for the movements people select as invoking the most vivid memory or story.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmems <- data$Movement_mem %>% na.omit() %>% toupper()\nstories <- data$Movement_story %>% na.omit() %>% toupper()\n\n\n# Split values by \";\", \",\", or whitespace\nsplit_values_mem <- unlist(strsplit(mems, \"[; ,]+\"))\nsplit_values_story <- unlist(strsplit(stories, \"[; ,]+\"))\n\n# Trim whitespace\nsplit_values_mem <- trimws(split_values_mem)\nsplit_values_story <- trimws(split_values_story)\n\n# Count occurrences\nvalue_counts_mem <- table(split_values_mem)\nvalue_counts_story <- table(split_values_story)\n```\n:::\n\n\n\nThe movement counts are then plotted.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Reorder the Movement factor levels for Beethoven and Hough\n\nrecode_map <- c(\"B1\" = \"Beethoven, Movement 1 — Allegro con brio\",\n                \"B2\" = \"Beethoven, Movement 2 — Adagio affettuoso ed appassionato\",\n                \"B3\" = \"Beethoven, Movement 3 — Scherzo\",\n                \"B4\" = \"Beethoven, Movement 4 — Allegro\",\n                \"H1\" = \"Hough, Movement 1 — Au boulevard\",\n                \"H2\" = \"Hough, Movement 2 — Au parc\",\n                \"H3\" = \"Hough, Movement 3 — À l'hôtel\",\n                \"H4\" = \"Hough, Movement 4 — Au théâtre\",\n                \"H5\" = \"Hough, Movement 5 — À l'église\",\n                \"H6\" = \"Hough, Movement 6 — Au marché\")\n\n\n# Recode values to descriptive names using recode_map\nrecoded_mem <- dplyr::recode(split_values_mem, !!!recode_map)\nrecoded_story <- dplyr::recode(split_values_story, !!!recode_map)\n\n# Convert recoded values to data frames\ndf_mem_counts <- as.data.frame(table(recoded_mem))\ncolnames(df_mem_counts) <- c(\"Movement\", \"count\")\n\ndf_story_counts <- as.data.frame(table(recoded_story))\ncolnames(df_story_counts) <- c(\"Movement\", \"count\")\n\n# Add a Composer column (Beethoven for B1-B4, Hough for H1-H6)\ndf_mem_counts$Composer <- ifelse(grepl(\"^Beethoven\", df_mem_counts$Movement), \"Beethoven\", \"Hough\")\ndf_story_counts$Composer <- ifelse(grepl(\"^Beethoven\", df_story_counts$Movement), \"Beethoven\", \"Hough\")\n\n# Set movement factor levels for proper ordering\ndf_mem_counts$Movement <- factor(df_mem_counts$Movement, levels = recode_map)\ndf_story_counts$Movement <- factor(df_story_counts$Movement, levels = recode_map)\n\n# Plot for 'memories'\nmem_plot <- ggplot(df_mem_counts, aes(x = Movement, y = count, fill = Movement)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  facet_wrap(~ Composer, scales = \"free_x\") +  # Separate Beethoven & Hough\n  theme_minimal() +\n  labs(title = \"Movement Counts for Memories\", x = \"Movement\", y = \"Count\") +\n theme(axis.title.x = element_blank(),  # Remove x-axis title\n        axis.text.x = element_blank(),   # Remove x-axis labels\n        axis.ticks.x = element_blank()) +\n  scale_fill_brewer(palette = \"Set3\") + \n  guides(fill = guide_legend(title = \"Movement\")) +\n  scale_y_continuous(breaks = scales::breaks_pretty(n = 5))  \n\n# Plot for 'stories'\nstory_plot <- ggplot(df_story_counts, aes(x = Movement, y = count, fill = Movement)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  facet_wrap(~ Composer, scales = \"free_x\") +  # Separate Beethoven & Hough\n  theme_minimal() +\n  labs(title = \"Movement Counts for Stories\", x = \"Movement\", y = \"Count\") +\n theme(axis.title.x = element_blank(),  # Remove x-axis title\n        axis.text.x = element_blank(),   # Remove x-axis labels\n        axis.ticks.x = element_blank()) +\n  scale_fill_brewer(palette = \"Set3\") + \n  guides(fill = guide_legend(title = \"Movement\")) +\n  scale_y_continuous(breaks = scales::breaks_pretty(n = 5)) \n```\n:::\n\n\n\nIn the next descriptive phase, we want to look at how demographics variables are associated with different types of thoughts. First, we tidy the demographics data and make sure it's classed in the right way.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Creating a 'floor' variable, with 2 factors showing downstairs and upstairs locations.\ndata <- data %>%\n  mutate(Floor = ifelse(Location %in% c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"), \"Downstairs\", \"Upstairs\")) %>% relocate(Floor, .after = Location)\n\n#Removing NA.s?\ndata <- data %>%\n  filter(!is.na(Age) & !is.na(Gender) & !is.na(Music_listening) & !is.na(Floor) & !is.na(Fictional_story) & !is.na(Practice)) %>%\n  filter(!is.infinite(Age) & !is.infinite(Gender) & !is.infinite(Music_listening) & \n         !is.infinite(Floor) & !is.infinite(Fictional_story) & !is.infinite(Practice))\n\n#Making sure demographic variables are classed in the right way.\ndata$Age <- as.numeric(data$Age)\ndata$Practice <- as.numeric(as.character(data$Practice))\ndata$Gender <- factor(data$Gender,  levels = c('Male', 'Female', 'Other'))\ndata$Music_listening <- factor(data$Music_listening, levels = c('Very rarely', 'Somewhat rarely', 'Moderately frequently', 'Frequently', 'Very frequently'))\ndata$Floor <- factor(data$Floor, levels = c('Downstairs', 'Upstairs'))\ndata$Fictional_story <- factor(data$Fictional_story, \n                               levels = c(\"Not at all\", \"A small amount of the time\", \n                                          \"A moderate amount of the time\", \n                                          \"Most of the time\", \"All of the time\"))\n```\n:::\n\n\n\nVarious descriptive plots can be made, but there are 3 below for age, gender and floor.\n\n1)  Descriptive plot for Age and types of thought -- age is converted into a grouped variable:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create Age bins\ndata <- data %>%\n  mutate(Age_group = cut(Age, \n                         breaks = seq(floor(min(Age, na.rm = TRUE)), \n                                      ceiling(max(Age, na.rm = TRUE)) + 20, by = 5), \n                         include.lowest = TRUE, \n                         right = FALSE))\n\n# List of outcome variables\noutcome_vars <- c(\"Fictional_story\", \"Abstract_shapes\", \"Sensory_sensations\", \n                  \"Life_experiences\", \"Media\", \"Music\", \"Future_plans\", \n                  \"Building\", \"Everyday\")\n\n# Converting outcome variables to factors with consistent levels for each thought type\ndata[outcome_vars] <- lapply(data[outcome_vars], factor, \n                             levels = c(\"Not at all\", \"A small amount of the time\", \n                                        \"A moderate amount of the time\", \"Most of the time\", \n                                        \"All of the time\"))\n\n# Creating a single summary_data dataframe\nsummary_data <- data %>%\n  pivot_longer(cols = all_of(outcome_vars), names_to = \"Outcome\", values_to = \"Response\") %>%\n  group_by(Age_group, Outcome, Response) %>%\n  summarise(count = n(), .groups = \"drop\") %>%\n  group_by(Age_group, Outcome) %>%\n  mutate(prop = count / sum(count)) %>%\n  ungroup()\n\n# Looping through each outcome variable to generate plots\nplot_list <- list()\n\nfor (outcome in outcome_vars) {\n    plot_data <- summary_data %>% filter(Outcome == outcome)\n    plot <- ggplot(plot_data, aes(x = Age_group, y = prop, fill = Response)) +\n      geom_bar(stat = \"identity\", position = \"stack\", alpha = 0.8) + \n      labs(x = \"\\nAge Group\", y = \"Proportion\\n\", title = paste(outcome)) +\n      scale_fill_manual(name = \"Response Level\",\n                        values = setNames(c(\"#deebf7\", \"#9ecae1\", \"#3182bd\", \"#08519c\", \"#08306b\"),\n                                          levels(data[[outcome]]))) +\n      theme_minimal() + \n      theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n  plot_list[[outcome]] <- plot\n}\n\n# Arranging plots in a grid and saving\n\ntitle_grob <- textGrob(\"Types of Thoughts by Age Group, First Half\", gp = gpar(fontsize = 16, fontface = \"bold\"))\n\nAge_thoughts_grid <- invisible(grid.arrange(\n  grobs = plot_list, \n  ncol = 3, \n  top = title_grob  \n))\n```\n\n::: {.cell-output-display}\n![](Descriptive1_files/figure-html/unnamed-chunk-12-1.png){width=1920}\n:::\n:::\n\n\n\n2)  Descriptive plot for gender and types of thought -- for now gender has been filtered for male and female.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove missing values + filter\ndata <- data %>%\n  filter(!is.na(Gender)) %>% filter(Gender != 'Other')\n\n# Create a single summary_data dataframe\nsummary_data <- data %>%\n  pivot_longer(cols = all_of(outcome_vars), names_to = \"Outcome\", values_to = \"Response\") %>%\n  group_by(Gender, Outcome, Response) %>%\n  summarise(count = n(), .groups = \"drop\") %>%\n  group_by(Gender, Outcome) %>%\n  mutate(prop = count / sum(count)) %>%\n  ungroup()\n\n# Looping through each outcome variable to generate plots\nplot_list <- list()\n\nfor (outcome in outcome_vars) {\n    plot_data <- summary_data %>% filter(Outcome == outcome)\n    plot <- ggplot(plot_data, aes(x = Gender, y = prop, fill = Response)) +\n      geom_bar(stat = \"identity\", position = \"stack\", alpha = 0.8) + \n      labs(x = \"\\nGender\", y = \"Proportion\\n\", title = paste(outcome)) +\n      scale_fill_manual(name = \"Response Level\",\n                        values = setNames(c(\"#deebf7\", \"#9ecae1\", \"#3182bd\", \"#08519c\", \"#08306b\"),\n                                          levels(data[[outcome]]))) +\n      theme_minimal() + \n      theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n  plot_list[[outcome]] <- plot\n}\n\ntitle_grob <- textGrob(\"Types of Thoughts by Gender, First Half\", gp = gpar(fontsize = 16, fontface = \"bold\"))\n\nGender_thoughts_grid <- grid.arrange(\n  grobs = plot_list, \n  ncol = 3, \n  top = title_grob  \n)\n```\n\n::: {.cell-output-display}\n![](Descriptive1_files/figure-html/unnamed-chunk-13-1.png){width=1920}\n:::\n:::\n\n\n\n3)  Descriptive plot for floor\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove missing values\ndata <- data %>%\n  filter(!is.na(Floor))\n\n# Create a single summary_data dataframe\nsummary_data <- data %>%\n  pivot_longer(cols = all_of(outcome_vars), names_to = \"Outcome\", values_to = \"Response\") %>%\n  group_by(Floor, Outcome, Response) %>%\n  summarise(count = n(), .groups = \"drop\") %>%\n  group_by(Floor, Outcome) %>%\n  mutate(prop = count / sum(count)) %>%\n  ungroup()\n\n# Looping through each outcome variable to generate plots\nplot_list <- list()\n\nfor (outcome in outcome_vars) {\n    plot_data <- summary_data %>% filter(Outcome == outcome)\n    plot <- ggplot(plot_data, aes(x = Floor, y = prop, fill = Response)) +\n      geom_bar(stat = \"identity\", position = \"stack\", alpha = 0.8) + \n      labs(x = \"\\nFloor\", y = \"Proportion\\n\", title = paste(outcome)) +\n      scale_fill_manual(name = \"Response Level\",\n                        values = setNames(c(\"#deebf7\", \"#9ecae1\", \"#3182bd\", \"#08519c\", \"#08306b\"),\n                                          levels(data[[outcome]]))) +\n      theme_minimal() + \n      theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n  plot_list[[outcome]] <- plot\n}\n\ntitle_grob <- textGrob(\"Types of Thoughts by Floor, First Half\", gp = gpar(fontsize = 16, fontface = \"bold\"))\n\nFloor_thoughts_grid <- grid.arrange(\n  grobs = plot_list, \n  ncol = 3, \n  top = title_grob  \n)\n```\n\n::: {.cell-output-display}\n![](Descriptive1_files/figure-html/unnamed-chunk-14-1.png){width=1920}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#Saving the data as a clean file\n#write.csv(data, \"C:/Users/htwil/OneDrive/Documents/Stats 504/Tutorial/data.csv\", row.names = FALSE)\n```\n:::\n",
    "supporting": [
      "Descriptive1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}